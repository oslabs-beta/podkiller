<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PodKiller</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<!-- Starfield Canvas -->
<canvas id="starfield-canvas"></canvas>

    <!-- TIE Fighter Cockpit Overlay -->
    <div class="cockpit-overlay">
        <img src="cockpit.png" alt="TIE Fighter Cockpit">
    </div>

    <!-- Main Dashboard Content -->
    <div class="dashboard-container">
        <div class="dashboard">
            <div class="left-column">
                <div class="panel control">
                    <h2>üéØ Control Panel</h2>
                    
                    <div class="status-card">
                        <div class="status-indicator">
                            <span class="status-dot" id="statusDot"></span>
                            <span id="statusText">Disconnected</span>
                        </div>
                        <button class="btn-success" id="minikubeBtn" onclick="startMinikube()">
                            Start Minikube
                        </button>
                    </div>

                    <div class="status-card">
                        <div class="status-indicator">
                            <span>üìÅ</span>
                            <span>Namespace: <strong>default</strong></span>
                        </div>
                    </div>

                    <div class="pods-section">
                        <div class="pods-header">
                            <div class="pods-title">
                                <span>üì¶</span>
                                <span>Active Pods</span>
                            </div>
                            <span class="pod-count" id="podCount">0</span>
                        </div>
                        <div class="pods-grid" id="podsList">
                        </div>
                    </div>

                    <div class="kill-button-container">
                        <button class="btn-danger" id="killBtn" onclick="killRandomPod()" disabled style="flex-grow: 1;">
                            üíÄ Kill Random Pod
                        </button>
                    </div>
                </div>

                <div class="panel activity">
                    <h2>üìã Activity Log</h2>
                    <div class="log-entries" id="logEntries">
                        <div class="empty-log">No activity yet. Kill a pod to see logs.</div>
                    </div>
                </div>
            </div>

            <div class="panel analytics">
                <h2>üìä Recovery Analytics</h2>
                <div class="chart-container">
                    <canvas id="chaosChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Starfield Animation Logic ---
        const canvas = document.getElementById('starfield-canvas');
        const ctx = canvas.getContext('2d');
        const numStars = 1000;
        const stars = [];
        const starColors = ['#FFFFFF', '#F0F8FF', '#ADD8E6', '#B0E0E6'];

        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function resetStar(star) {
            const minStartRadius = 150;
            const maxStartRadius = Math.max(canvas.width, canvas.height) / 2 + 100;
            const angle = Math.random() * 2 * Math.PI;
            const radius = Math.random() * (maxStartRadius - minStartRadius) + minStartRadius;
            
            star.x = radius * Math.cos(angle);
            star.y = radius * Math.sin(angle);
            star.z = canvas.width;
            star.color = starColors[Math.floor(Math.random() * starColors.length)];
            star.baseSize = Math.random() * 3 + 1.5;
            star.twinkle = false;
        }

        function createStars() {
            stars.length = 0;
            for (let i = 0; i < numStars; i++) {
                const star = {};
                resetStar(star);
                star.z = Math.random() * canvas.width;
                stars.push(star);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Clear canvas with black background
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < numStars; i++) {
                const star = stars[i];
                star.z -= 0.375; // Speed for movement

                if (star.z <= 0) {
                    resetStar(star);
                }

                const screenX = (star.x / star.z) * canvas.width + canvas.width / 2;
                const screenY = (star.y / star.z) * canvas.height + canvas.height / 2;
                const size = (1 - star.z / canvas.width) * star.baseSize;
                
                // Calculate alpha for brightness and twinkling
                const baseAlpha = Math.max(0.3, (1 - star.z / canvas.width));
                const alpha = star.twinkle ? (Math.random() * 0.7 + 0.3) : baseAlpha;
                
                // Draw the star
                ctx.beginPath();
                ctx.arc(screenX, screenY, Math.max(0.5, size), 0, Math.PI * 2);
                ctx.fillStyle = star.color;
                ctx.globalAlpha = alpha;
                ctx.fill();
                ctx.globalAlpha = 1.0; // Reset alpha
            }
        }

        // Twinkling effect
        setInterval(() => {
            const numTwinklingStars = Math.floor(Math.random() * 5) + 2;
            for (let i = 0; i < numTwinklingStars; i++) {
                const randomIndex = Math.floor(Math.random() * stars.length);
                stars[randomIndex].twinkle = true;
                setTimeout(() => {
                    stars[randomIndex].twinkle = false;
                }, 150);
            }
        }, 300);

        // Initialize starfield
        function initStarfield() {
            setCanvasSize();
            createStars();
            animate();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            setCanvasSize();
            createStars(); // Recreate stars for new dimensions
        });

        // App State
        let isConnected = false;
        let currentNamespace = 'default';
        let pods = [];
        let activityLog = [];
        let chart = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initStarfield();
            checkConnection();
            setInterval(checkConnection, 5000); // Check connection every 5 seconds
            addLogEntry('Dashboard initialized', 'info');
            initializeChart();
            fetchReports();
        });

        // Initialize empty chart
        function initializeChart() {
            const ctx = document.getElementById('chaosChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Recovery Time (seconds)',
                        data: [],
                        borderColor: 'rgba(255, 99, 132, 1)',
                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                        fill: true,
                        tension: 0.1,
                        pointBackgroundColor: 'rgba(255, 99, 132, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgba(255, 99, 132, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Recovery Time (seconds)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Time of Chaos Event'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const value = context.parsed.y;
                                    return `Recovery Time: ${value.toFixed(2)}s`;
                                }
                            }
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        // Fetch and display recovery reports
        async function fetchReports() {
            try {
                addLogEntry('Loading recovery analytics...', 'info');
                const response = await fetch('http://localhost:3000/api/reports');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.reports || data.reports.length === 0) {
                    addLogEntry('No recovery data found', 'info');
                    return;
                }

                const reports = data.reports
                const labels = reports.map((r) =>
                    new Date(r.deletionTime).toLocaleTimeString()
                );
                const recoveryTimes = reports.map((r) => r.recoveryTime);

                // Update chart data
                chart.data.labels = labels;
                chart.data.datasets[0].data = recoveryTimes;
                chart.update();

                addLogEntry(`Loaded ${reports.length} recovery records`, 'success');
            } catch (error) {
                addLogEntry('Failed to load recovery data: ' + error.message, 'error');
                console.error('Error fetching reports:', error);
            }
        }

        // Refresh chart data
        function refreshChart() {
            fetchReports();
        }

        // Check Minikube connection
        async function checkConnection() {
            try {
                const response = await fetch('/api/status');
                if (response.ok) {
                    setConnectionStatus(true);
                    if (isConnected) {
                        loadPods(); // Auto-load pods when connected
                    }
                } else {
                    setConnectionStatus(false);
                }
            } catch (error) {
                setConnectionStatus(false);
            }
        }

        // Set connection status
        function setConnectionStatus(connected) {
            isConnected = connected;
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            const killBtn = document.getElementById('killBtn');
            const minikubeBtn = document.getElementById('minikubeBtn');
            
            if (connected) {
                statusDot.classList.add('connected');
                statusText.textContent = 'Connected to Minikube';
                killBtn.disabled = false;
                minikubeBtn.textContent = 'Minikube Running';
                minikubeBtn.disabled = true;
                if (!activityLog.some(log => log.message.includes('Connected to Minikube'))) {
                    addLogEntry('Connected to Minikube', 'success');
                }
            } else {
                statusDot.classList.remove('connected');
                statusText.textContent = 'Disconnected';
                killBtn.disabled = true;
                minikubeBtn.textContent = 'Start Minikube';
                minikubeBtn.disabled = false;
            }
        }

        // Start Minikube
        async function startMinikube() {
            const btn = document.getElementById('minikubeBtn');
            btn.innerHTML = '<span class="spinner"></span>Starting...';
            btn.disabled = true;
            
            addLogEntry('Starting Minikube...', 'info');
            
            try {
                const response = await fetch('/api/minikube/start', { method: 'POST' });
                
                if (response.ok) {
                    addLogEntry('Minikube started successfully', 'success');
                    setConnectionStatus(true);
                    loadPods();
                } else {
                    throw new Error('Failed to start Minikube');
                }
            } catch (error) {
                addLogEntry('Failed to start Minikube: ' + error.message, 'error');
                btn.innerHTML = 'Start Minikube';
                btn.disabled = false;
            }
        }

        // Load pods list (auto-refresh)
        async function loadPods() {
            if (!isConnected) {
                renderPods();
                return;
            }

            try {
                const response = await fetch(`/api/pods/default`);
                
                if (response.ok) {
                    const data = await response.json();
                    pods = data.pods || [];
                    renderPods();
                } else {
                    throw new Error('Failed to fetch pods');
                }
            } catch (error) {
                addLogEntry('Failed to load pods: ' + error.message, 'error');
                pods = [];
                renderPods();
            }
        }

        // Render pods list
        function renderPods() {
            const podsList = document.getElementById('podsList');
            const podCount = document.getElementById('podCount');
            
            podCount.textContent = pods.length;
            
            if (pods.length === 0) {
                podsList.innerHTML = `<div class="pod-item">
                    <span class="pod-name">No pods found</span>
                    <span class="pod-status">Empty namespace</span>
                </div>`;
                return;
            }
            
            podsList.innerHTML = pods.map(pod => `
                <div class="pod-item ${pod.status === 'Terminating' ? 'terminating' : ''}">
                    <span class="pod-name">${pod.name}</span>
                    <span class="pod-status">${pod.status}</span>
                </div>
            `).join('');
        }

        // Kill random pod
        async function killRandomPod() {
            if (!isConnected || pods.length === 0) {
                addLogEntry('No pods available to kill', 'error');
                return;
            }

            const btn = document.getElementById('killBtn');
            btn.innerHTML = '<span class="spinner"></span>Killing...';
            btn.disabled = true;

            const runningPods = pods.filter(p => p.status === 'Running');
            if (runningPods.length === 0) {
                addLogEntry('No running pods to kill', 'error');
                btn.innerHTML = 'üíÄ Kill Random Pod';
                btn.disabled = false;
                return;
            }

            const targetPod = runningPods[Math.floor(Math.random() * runningPods.length)];
            
            try {
                const response = await fetch('/api/kill', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        podName: targetPod.name,
                        namespace: 'default'
                    })
                });

                // Add a small delay to allow K8 to process the deletion
                setTimeout(() => {
                    loadPods();
                }, 2000);

                if (response.ok) {
                    const result = await response.json();
                    addLogEntry(`Pod killed: ${targetPod.name}`, 'kill');

                    if (result.recoveryTime !== null) {
                        addLogEntry(`Pod recovered in ${result.recoveryTime.toFixed(2)} seconds`, 'success');
                        
                        // Auto-refresh chart data after a successful kill
                        setTimeout(() => {
                            fetchReports();
                        }, 1000);
                    } else {
                        addLogEntry('Pod killed, but no new replacement pod found.', 'info');
                    }

                    // Reload pods again after the response to show final state
                    loadPods();

                } else {
                    throw new Error('Failed to kill pod');
                }
            } catch (error) {
                addLogEntry('Failed to kill pod: ' + error.message, 'error');
            }

            btn.innerHTML = 'üíÄ Kill Random Pod';
            btn.disabled = false;
        }

        // Add log entry
        function addLogEntry(message, type = 'info') {
            const time = new Date().toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit' 
            });
            
            const logEntry = {
                time: time,
                message: message,
                type: type
            };
            
            activityLog.unshift(logEntry);
            if (activityLog.length > 50) {
                activityLog = activityLog.slice(0, 50);
            }
            
            renderLogs();
        }

        // Render activity logs
        function renderLogs() {
            const logEntries = document.getElementById('logEntries');
            
            if (activityLog.length === 0) {
                logEntries.innerHTML = '<div class="empty-log">No activity yet. Kill a pod to see logs.</div>';
                return;
            }
            
            logEntries.innerHTML = activityLog.map(log => `
                <div class="log-entry ${log.type}">
                    <div class="log-time">${log.time}</div>
                    <div class="log-message">${log.message}</div>
                </div>
            `).join('');
        }

        // Auto-refresh pods every 5 seconds when connected
        setInterval(() => {
            if (isConnected) {
                loadPods();
            }
        }, 5000);
    </script>
</body>
</html>